\begin{code}[hide]%
\>[0]\AgdaSymbol{\{-\#}\AgdaSpace{}%
\AgdaKeyword{OPTIONS}\AgdaSpace{}%
\AgdaPragma{--type-in-type}\AgdaSpace{}%
\AgdaSymbol{\#-\}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{module}\AgdaSpace{}%
\AgdaModule{Trial}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Product}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaRecord{Σ}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}×\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{\AgdaUnderscore{},\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{proj₁}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaField{proj₂}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{∃}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{Σ-syntax}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{∃-syntax}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Nat}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaDatatype{ℕ}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Data.Unit}\<%
\\
\>[0]\AgdaKeyword{import}\AgdaSpace{}%
\AgdaModule{Relation.Binary.PropositionalEquality}\AgdaSpace{}%
\AgdaSymbol{as}\AgdaSpace{}%
\AgdaModule{Eq}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Eq}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaDatatype{\AgdaUnderscore{}≡\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaInductiveConstructor{refl}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{trans}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{sym}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{cong}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{cong-app}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{subst}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Eq.≡-Reasoning}\AgdaSpace{}%
\AgdaKeyword{using}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaOperator{\AgdaFunction{begin\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}≡⟨⟩\AgdaUnderscore{}}}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaFunction{step-≡}\AgdaSymbol{;}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}∎}}\AgdaSymbol{)}\<%
\end{code}

In this example, we follow the dependently typed approach initiated by Ranta to
do inference on actual FraCas examples.

Initially, one takes the common nouns as types literally, by saying that the
type of common nouns is actually just a universe, which simply gives the
universe an alias of \term{CN} in Agda, $\llbracket CN \rrbracket := Set$. A man
is common noun, so semantically we just say $\llbracket Man \rrbracket\; {:}\;
\llbracket CN \rrbracket$. And if there is a man John, we simply assert
$\llbracket John \rrbracket\; {:}\; \llbracket Man \rrbracket$.

\begin{code}%
\>[0]\AgdaFunction{CN}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{postulate}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaPostulate{man}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{CN}\<%
\\
%
\>[2]\AgdaPostulate{john}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{man}\<%
\end{code}

In Agda, there is only one sort of predicative universe, \term{Set}. In Coq
there are both impredicative and predicative universes, \term{Prop} and
\term{Set} respectively, of which \term{Type} is a superclass. While one defines
\term{CN := Set} in Coq, the type of impredicative propositions are included in
both \cite{fracoq} and \cite{luoCoq} which is not possible in Agda. It should be
possible to make everything predicative in Coq, but the authors' reasons for
using impredicativity were not explicated in their work. Agda's \term{Prop} are
by default proof irrelevant, whereas one must choose to make Coq's propositions
proof irrelevant. We don't explore more about the implications of foundations
here.

Once one has a the universe of common nouns, each of which may have many
inhabitants, we can ask how they are modified. Intransative Verbs (IVs) like
``walk", can be seen as a type restricted by the collection of things which have
the ability to walk, such as animals. We can see such verbs as functions taking a
specific type of common noun to an arbitrary type : $\llbracket IV \rrbracket\;
{:}\; (\llbracket x \rrbracket\; {:}\; \llbracket CN \rrbracket) \rightarrow
Set$

\begin{code}[hide]%
\>[0]\AgdaKeyword{postulate}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaPostulate{animal}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\end{code}
\begin{code}%
\>[0]\AgdaKeyword{postulate}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaPostulate{walk}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{animal}\AgdaSpace{}%
\AgdaSymbol{->}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\end{code}
\begin{code}[hide]%
\>[0]\AgdaKeyword{postulate}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaPostulate{delegate}\AgdaSpace{}%
\AgdaPostulate{survey}\AgdaSpace{}%
\AgdaPostulate{object}\AgdaSpace{}%
\AgdaPostulate{surgeon}\AgdaSpace{}%
\AgdaPostulate{human}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{CN}\<%
\end{code}

We can then encode the quantiers, noting that they also return just types the
dependent type \term{P} below is propositional in Coq. These are more arguably
more syntactically pleasing than our Mongtagovian semantics, because they only
bind a noun and a property about that noun, rather than rigidly requiring a verb
phrase and a noun phrase as arguments.

\begin{code}%
\>[0]\AgdaFunction{some}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{CN}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaFunction{some}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{Σ[}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaFunction{∈}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{all}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{CN}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaFunction{all}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{P}\AgdaSpace{}%
\AgdaBound{x}\<%
\end{code}

Wanting to do inference with these examples, we hope to show that if John is a
man and every man walks, then John walks. The difficulty is that walk is a type
over animals, not men, and the relation between men and animals are not yet
covered by our type theory. The theory of coercive subtyping rectifies this and
gives a mechanism of implicity coercing the type of men to the type of animals,
as indeed all men are animals. One can form an order from the subtypes, with
possible infima and suprema, that may transform some abstract ontological model
of the domain into specific ways of using the information to prove inferences.

The coercions in coercive type theory can be approximated by the use of
Agda's instance arguements, which are indicated with \codeword{{{_}}} below.
Nonetheless, Agda doesn't support coercive subtyping as developed by Luo, and
therefore has weaknesses relative to Coq when it comes to eliminating ``coercion
bureaucracy". A coercion is a record type parameterized by two types $x$ and $y$
with one field \term{coe} which is merely a mapping from $x$ to $y$. We can then
compose and apply functions with arguements for which there exists an coercion.

\begin{code}%
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{Coercion}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{a}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{x}\AgdaSpace{}%
\AgdaBound{y}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaBound{a}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{constructor}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌞\AgdaUnderscore{}⌟}}\<%
\\
%
\>[2]\AgdaKeyword{field}\AgdaSpace{}%
\AgdaField{coe}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{y}\<%
\end{code}
\begin{code}[hide]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Coercion}\<%
\end{code}
\begin{code}%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⊚\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{a}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaBound{C}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaBound{a}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Coercion}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Coercion}\AgdaSpace{}%
\AgdaBound{B}\AgdaSpace{}%
\AgdaBound{C}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{Coercion}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{C}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}⊚\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{c}\AgdaSpace{}%
\AgdaBound{d}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌞}}\AgdaSpace{}%
\AgdaSymbol{(λ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaField{coe}\AgdaSpace{}%
\AgdaBound{d}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{coe}\AgdaSpace{}%
\AgdaBound{c}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌟}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}\$\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaSymbol{:}%
\>[154I]\AgdaSymbol{∀}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{b}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{A′}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaBound{a}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{B}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaBound{b}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\<%
\\
\>[.][@{}l@{}]\<[154I]%
\>[6]\AgdaSymbol{\{\{}\AgdaBound{c}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Coercion}\AgdaSpace{}%
\AgdaBound{A′}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{\}\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A′}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{B}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{\AgdaUnderscore{}\$\AgdaUnderscore{}}}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{\{\{}\AgdaBound{c}\AgdaSymbol{\}\}}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{f}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{coe}\AgdaSpace{}%
\AgdaBound{c}\AgdaSpace{}%
\AgdaBound{a}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{postulate}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaPostulate{ha}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{human}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPostulate{animal}\<%
\\
%
\>[2]\AgdaPostulate{mh}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{man}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPostulate{human}\<%
\end{code}

The instance arguements, similar to Haskell's type-classes, allow one to
introduce the coercion information into a context so that one may compute with
these hidden typing relations.

\begin{code}%
\>[0]\AgdaKeyword{instance}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaFunction{hac}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌞}}\AgdaSpace{}%
\AgdaPostulate{ha}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌟}}\<%
\\
%
\>[2]\AgdaFunction{mhc}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌞}}\AgdaSpace{}%
\AgdaPostulate{mh}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌟}}\<%
\\
%
\>[2]\AgdaFunction{mac}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{mhc}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊚}}\AgdaSpace{}%
\AgdaFunction{hac}\<%
\end{code}

Once one has defined instances, Agda can infer that \term{walk} is a property of
men, which should be subtypes of animals. We must explictly explicitly declare
this in Agda, unfortunately. A type theory with native support for coercive
subtyping would save significant hassle, although someone with significant
experience using Agda's instance arguements might find a superior way to do this
rather than generating all the instances and coercion applications, possibly
without resorting to metaprogramming. However, once we have the infastracture in
place, we can not only infer basic facts about men, but also about animals and
their relation to men.

\begin{code}[hide]%
\>[0]\AgdaFunction{manwalk}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{man}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaFunction{manwalk}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPostulate{walk}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\AgdaSpace{}%
\AgdaBound{m}\<%
\end{code}
\begin{code}%
\>[0]\AgdaFunction{johnwalk}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{manwalk}\AgdaSpace{}%
\AgdaPostulate{john}\<%
\\
\>[0]\AgdaFunction{allmanwalk}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{all}\AgdaSpace{}%
\AgdaPostulate{man}\AgdaSpace{}%
\AgdaFunction{manwalk}\<%
\\
\>[0]\AgdaFunction{somemanwalk}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{some}\AgdaSpace{}%
\AgdaPostulate{man}\AgdaSpace{}%
\AgdaFunction{manwalk}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{thm1}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{allmanwalk}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{johnwalk}\<%
\\
\>[0]\AgdaFunction{thm1}\AgdaSpace{}%
\AgdaBound{∀mWalk[m]}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{∀mWalk[m]}\AgdaSpace{}%
\AgdaPostulate{john}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{thm2}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{johnwalk}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{somemanwalk}\<%
\\
\>[0]\AgdaFunction{thm2}\AgdaSpace{}%
\AgdaBound{jw}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPostulate{john}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{jw}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{thm3}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{somemanwalk}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{some}\AgdaSpace{}%
\AgdaPostulate{animal}\AgdaSpace{}%
\AgdaPostulate{walk}\<%
\\
\>[0]\AgdaFunction{thm3}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{walk[m]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPostulate{ha}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPostulate{mh}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{walk[m]}\<%
\end{code}

To the best of our knowledge, there is no way of coercing types directly, as in,
one cannot simply force the type-checker in \term{thm3} to accept the man
arguement without explicitly requiring the programmer to insert the coercions,
\term{ha (mh m)}. Another issue is that \term{manwalk} and \term{walk} are
explicitly different types, despite the instances allowing Agda to coerce the
fact that a man walks, \codeword{walk[m]}, to an animal walking. We may
reconcile this with more instance arguements, whereby we create a parameterized
record \term{Walks} with a single data point for the walking capacity. One can
then overload walks with all the different entities which can walk, and thereby
not have the ugly \term{manwalks} in the type signature of \term{thm3'}.

\begin{code}%
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{Walks}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{a}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaBound{a}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{walks}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{Walks}\AgdaSpace{}%
\AgdaSymbol{\{\{...\}\}}\AgdaSpace{}%
\AgdaKeyword{public}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{postulate}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaPostulate{animalsWalk}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Walks}\AgdaSpace{}%
\AgdaPostulate{animal}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{instance}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaFunction{animalwalks}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Walks}\AgdaSpace{}%
\AgdaPostulate{animal}\<%
\\
%
\>[2]\AgdaFunction{animalwalks}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPostulate{animalsWalk}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{humanwalks}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Walks}\AgdaSpace{}%
\AgdaPostulate{human}\<%
\\
%
\>[2]\AgdaFunction{humanwalks}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaKeyword{record}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaField{walks}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{h}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaField{Walks.walks}\AgdaSpace{}%
\AgdaPostulate{animalsWalk}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\AgdaSpace{}%
\AgdaBound{h}\AgdaSymbol{\}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{manwalks}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Walks}\AgdaSpace{}%
\AgdaPostulate{man}\<%
\\
%
\>[2]\AgdaFunction{manwalks}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaKeyword{record}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaField{walks}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaField{Walks.walks}\AgdaSpace{}%
\AgdaPostulate{animalsWalk}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\AgdaSpace{}%
\AgdaBound{m}\AgdaSymbol{\}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{thm3'}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{some}\AgdaSpace{}%
\AgdaPostulate{man}\AgdaSpace{}%
\AgdaField{walks}%
\>[24]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{some}\AgdaSpace{}%
\AgdaPostulate{human}\AgdaSpace{}%
\AgdaField{walks}\<%
\\
\>[0]\AgdaFunction{thm3'}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{walk[m]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPostulate{mh}\AgdaSpace{}%
\AgdaBound{m}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{walk[m]}\<%
\end{code}

\subsection{Irish Delegate Example}

We finish with the following FraCas example, which includes the ditransative
verb ``finished", the adjective ``Irish", and adverb ``on time", and the
determiner ``the". We include a common noun for \term{object}, of which
\term{survey} and \term{animal} should be subtypes.

\begin{verbatim}
Premise  : Some Irish delegates finished the survey on time.
Question : Did any delegates finish the survey on time?
Answer   : Yes.
\end{verbatim}

\begin{code}[hide]%
\>[0]\AgdaKeyword{postulate}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaPostulate{ao}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{animal}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPostulate{object}\<%
\\
%
\>[2]\AgdaPostulate{dh}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{delegate}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPostulate{human}\<%
\\
%
\>[2]\AgdaPostulate{so}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{survey}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPostulate{object}\<%
\\
\>[0]\AgdaKeyword{instance}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaFunction{aoc}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌞}}\AgdaSpace{}%
\AgdaPostulate{ao}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌟}}\<%
\\
%
\>[2]\AgdaFunction{dhc}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌞}}\AgdaSpace{}%
\AgdaPostulate{dh}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌟}}\<%
\\
%
\>[2]\AgdaFunction{soc}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌞}}\AgdaSpace{}%
\AgdaPostulate{so}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌟}}\<%
\\
%
\>[2]\AgdaFunction{dac}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{dhc}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊚}}\AgdaSpace{}%
\AgdaFunction{hac}\AgdaSpace{}%
\AgdaComment{--added}\<%
\\
%
\>[2]\AgdaFunction{hoc}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{hac}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊚}}\AgdaSpace{}%
\AgdaFunction{aoc}\<%
\\
%
\>[2]\AgdaFunction{doc}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaFunction{dhc}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊚}}\AgdaSpace{}%
\AgdaFunction{hac}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊚}}\AgdaSpace{}%
\AgdaFunction{aoc}\<%
\end{code}

Semantically, Ditransitive Verbs (DVs) are similair to IVs, they are just binary
functions instead of unary.

$$\llbracket DV \rrbracket\; {:}\; (\llbracket x \rrbracket\; {:}\; \llbracket
CN \rrbracket) \rightarrow (\llbracket y \rrbracket\; {:}\; \llbracket CN
\rrbracket) \rightarrow Set$$

The quality of being on time, which modifies a verb, is intpreted as a function
which takes a common noun $cn$, a type indexed by $cn$ (the verb), and returns a
type which is itself dependent on $cn$. The intuition that one can continue to
modify a verb phrase with more adverbs is immediately obvious based of the type
signature, because it returns the same type as a verb after taking a verb as an
arguement.

$$\llbracket ADV \rrbracket\; {:}\; (\Pi \; x \; {:}\;
\llbracket CN \rrbracket) \rightarrow (\llbracket x \rrbracket\; \rightarrow
Set) \rightarrow (\llbracket x \rrbracket\; \rightarrow Set)$$

The determiner ``the" is simply a way of extracting a member from a given CN.

$$\llbracket the \rrbracket\; {:}\; (\Pi \; x \; {:}\; \llbracket CN \rrbracket) \rightarrow x)$$

Finally, the MTT interpretation of adjectives is definitionally equal to IVs,
$\llbracket ADJ \rrbracket\; {:}\; (\llbracket x \rrbracket\; {:}\; \llbracket
CN \rrbracket) \rightarrow Set$. This does not mean they are semantically at all
similar. Verbs describe what an individual does, whereas adjectives describe
some property of the individual. To apply an adjective $a$ to a member $n$ of
some CN gives a sentence whose meaning is ``$a$ is $n$", whereby the syntactic
``is" is implicit in the semantics.

\begin{code}%
\>[0]\AgdaKeyword{postulate}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaPostulate{finish}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{object}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPostulate{human}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\>[2]\AgdaPostulate{ontime}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{CN}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSymbol{)}\<%
\\
%
\>[2]\AgdaPostulate{the}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{CN}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}%
\>[20]\AgdaBound{A}\<%
\\
%
\>[2]\AgdaPostulate{irish}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{object}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\end{code}

Adjectives are generally not meant to return sentences, but other common
nouns. Therefore, we can leverage the dependent product type or records more
generally to describe modified common nouns, whereby the first element $c$ is a
member of some CN and the second member is a proof that $c$ has the property the
adjective expresses. We can therefore see the example of \term{irishdelegate} as
such in Agda:

\begin{code}[hide]%
\>[0]\AgdaFunction{dobj}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{delegate}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPostulate{object}\<%
\\
\>[0]\AgdaFunction{dobj}\AgdaSpace{}%
\AgdaBound{del}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPostulate{ao}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPostulate{ha}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPostulate{dh}\AgdaSpace{}%
\AgdaBound{del}\AgdaSymbol{))}\<%
\end{code}
\begin{code}%
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{irishdelegate}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{CN}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{constructor}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{mkIrishdelegate}\<%
\\
%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{c}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{delegate}\<%
\\
%
\>[4]\AgdaField{ic}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{irish}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\AgdaSpace{}%
\AgdaField{c}\<%
\end{code}

We can follow the same methodology as before, coercing Irish delegates to
delegates axiomatically, and then applying the semantic interpretations of the
words such that the types align correctly - where one sees this actually follows
from an intuitive syntactic presentation.

\begin{code}[hide]%
\>[0]\AgdaKeyword{postulate}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaPostulate{idd}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{irishdelegate}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPostulate{delegate}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{instance}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaFunction{iddc}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌞}}\AgdaSpace{}%
\AgdaPostulate{idd}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌟}}\<%
\\
%
\>[2]\AgdaFunction{idh}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{iddc}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊚}}\AgdaSpace{}%
\AgdaFunction{dhc}\<%
\end{code}
\begin{code}[hide]%
\>[0]\AgdaFunction{finishTheSurvey}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{human}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaFunction{finishTheSurvey}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPostulate{finish}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPostulate{the}\AgdaSpace{}%
\AgdaPostulate{survey}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{finishedTheSurveyOnTime}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{delegate}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaFunction{finishedTheSurveyOnTime}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPostulate{ontime}\AgdaSpace{}%
\AgdaPostulate{human}\AgdaSpace{}%
\AgdaFunction{finishTheSurvey}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{someDelegateFinishedTheSurveyOnTime}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaFunction{someDelegateFinishedTheSurveyOnTime}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{some}\AgdaSpace{}%
\AgdaPostulate{delegate}\AgdaSpace{}%
\AgdaFunction{finishedTheSurveyOnTime}\<%
\end{code}

Once one builds a parallel infastructure for \term{irishdelegate}, one can then
proceed with the inference. We note that the work has to be doubled because
\term{finishedTheSurveyOnTime} and \term{someDelegateFinishedTheSurveyOnTime}
need to be refactored, renaming \term{delegate} to \term{irishdelegate}. Again,
this inference is just the identity function modulo an explicit \term{idd}
coercion, and implicit coercions allowing \codeword{finishedOnTime} to be cast to
its most general formulation where it is parameterized \term{human}.

\begin{code}[hide]%
\>[0]\AgdaFunction{finishedTheSurveyOnTime'}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{irishdelegate}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaFunction{finishedTheSurveyOnTime'}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaPostulate{ontime}\AgdaSpace{}%
\AgdaPostulate{human}\AgdaSpace{}%
\AgdaFunction{finishTheSurvey}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{someIrishDelegateFinishedTheSurveyOnTime}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaFunction{someIrishDelegateFinishedTheSurveyOnTime}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{some}\AgdaSpace{}%
\AgdaRecord{irishdelegate}\AgdaSpace{}%
\AgdaFunction{finishedTheSurveyOnTime'}\<%
\end{code}
\begin{code}%
\>[0]\AgdaFunction{fc55}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaFunction{someIrishDelegateFinishedTheSurveyOnTime}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{someDelegateFinishedTheSurveyOnTime}\<%
\\
\>[0]\AgdaFunction{fc55}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{irishDelegate}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{finishedOnTime}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPostulate{idd}\AgdaSpace{}%
\AgdaBound{irishDelegate}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{finishedOnTime}\<%
\end{code}

We note that one could have instead included an extensionality clause for
adjectives and adverbs, wherby one gives additional information so that the
arguement and return types, dependent on some CN $A$, behave coherently with
respect to arbitrary arguements of $A$. One can then derive the adverb by
forgetting the extensionality clause. The inference works out the same.

\begin{code}%
\>[0]\AgdaKeyword{postulate}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaPostulate{ADV}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{CN}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{v}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Σ[}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaFunction{∈}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaFunction{]}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{p}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaOperator{\AgdaFunction{on\AgdaUnderscore{}time}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{CN}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{v}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaOperator{\AgdaFunction{on\AgdaUnderscore{}time}}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{v}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaField{proj₁}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPostulate{ADV}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaBound{v}\AgdaSymbol{)}\<%
\end{code}
\begin{code}[hide]%
\>[0]\AgdaFunction{2finishedTheSurveyOnTime}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{delegate}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaFunction{2finishedTheSurveyOnTime}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{on\AgdaUnderscore{}time}}\AgdaSpace{}%
\AgdaPostulate{human}\AgdaSpace{}%
\AgdaFunction{finishTheSurvey}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{2finishedTheSurveyOnTime'}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{irishdelegate}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaFunction{2finishedTheSurveyOnTime'}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{on\AgdaUnderscore{}time}}\AgdaSpace{}%
\AgdaPostulate{human}\AgdaSpace{}%
\AgdaFunction{finishTheSurvey}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\AgdaSpace{}%
\AgdaBound{x}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{2someIrishDelegateFinishedTheSurveyOnTime}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaFunction{2someIrishDelegateFinishedTheSurveyOnTime}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{some}\AgdaSpace{}%
\AgdaRecord{irishdelegate}\AgdaSpace{}%
\AgdaFunction{2finishedTheSurveyOnTime'}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{2someDelegateFinishedTheSurveyOnTime}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaFunction{2someDelegateFinishedTheSurveyOnTime}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{some}\AgdaSpace{}%
\AgdaPostulate{delegate}\AgdaSpace{}%
\AgdaFunction{2finishedTheSurveyOnTime}\<%
\end{code}
\begin{code}%
\>[0]\AgdaFunction{fc55'}\AgdaSpace{}%
\AgdaSymbol{:}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaFunction{2someIrishDelegateFinishedTheSurveyOnTime}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{2someDelegateFinishedTheSurveyOnTime}\<%
\\
\>[0]\AgdaFunction{fc55'}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{irishDelegate}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{finishedOnTime}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPostulate{idd}\AgdaSpace{}%
\AgdaBound{irishDelegate}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{finishedOnTime}\<%
\end{code}

We now investigate the possiblity of gereralizing Irish, as well as integrating
the adjectival work with our previous work generating instance arguements for
``walks".

Unlike walking, which was assumed to apply to all animals, being Irish is a
restriction on the set of objects of some given domain. Therefore we can't just
define the record parametrically for all common nouns, but rather must include
an instance arguement for the coercion. Note this would break the semantic model
if we were to include the type of common noun ``Swede" with a coercion to
humans, because one would be able to make an Irish Swede.

\begin{code}%
\>[0]\AgdaKeyword{record}\AgdaSpace{}%
\AgdaRecord{irishThing}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{CN}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{\{\{}\AgdaBound{c}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Coercion}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaPostulate{object}\AgdaSymbol{\}\}}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{CN}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaKeyword{constructor}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaInductiveConstructor{mkIrish}\<%
\\
%
\>[2]\AgdaKeyword{field}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaField{thing}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
%
\>[4]\AgdaField{isIrish}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{irish}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\AgdaSpace{}%
\AgdaField{thing}\<%
\end{code}
\begin{code}[hide]%
\>[0]\AgdaKeyword{open}\AgdaSpace{}%
\AgdaModule{irishThing}\AgdaSpace{}%
\AgdaSymbol{\{\{...\}\}}\AgdaSpace{}%
\AgdaKeyword{public}\<%
\end{code}

Once can now delcare Irish entities using the record for humans, delegates, and
animals, where one can include the coercion arguements explicitly, even though
they are inferrable. Thereafter, we can overload walks even more. Although it is
clear that a lot of this code is boilerplate, the instance declarations must be
nullary, and basic code generation techniques would be needed to scale this to a
larger corpus. The point is, once we know that animals walk, anything subsumed
under that category is straightforward to make ``walkable".

\begin{code}%
\>[0]\AgdaFunction{IrishDelegate}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaRecord{irishThing}\AgdaSpace{}%
\AgdaPostulate{delegate}\AgdaSpace{}%
\AgdaSymbol{\{\{}\AgdaFunction{doc}\AgdaSymbol{\}\}}\<%
\\
\>[0]\AgdaFunction{IrishHuman}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaRecord{irishThing}\AgdaSpace{}%
\AgdaPostulate{human}\AgdaSpace{}%
\AgdaSymbol{\{\{}\AgdaFunction{hoc}\AgdaSymbol{\}\}}\<%
\\
\>[0]\AgdaFunction{IrishAnimal}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaRecord{irishThing}\AgdaSpace{}%
\AgdaPostulate{animal}\AgdaSpace{}%
\AgdaSymbol{\{\{}\AgdaFunction{aoc}\AgdaSymbol{\}\}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{instance}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaFunction{irishAnimalWalks}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Walks}\AgdaSpace{}%
\AgdaFunction{IrishAnimal}\<%
\\
%
\>[2]\AgdaFunction{irishAnimalWalks}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaKeyword{record}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaField{walks}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{helper}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaKeyword{where}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaFunction{helper}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{irishThing}\AgdaSpace{}%
\AgdaPostulate{animal}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\>[6]\AgdaFunction{helper}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{mkIrish}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{isIrish₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaField{Walks.walks}\AgdaSpace{}%
\AgdaPostulate{animalsWalk}\AgdaSpace{}%
\AgdaBound{a}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
%
\>[2]\AgdaFunction{irishHumanWalks}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Walks}\AgdaSpace{}%
\AgdaFunction{IrishHuman}\<%
\\
%
\>[2]\AgdaFunction{irishHumanWalks}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaKeyword{record}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaField{walks}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{helper}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaKeyword{where}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaFunction{helper}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{irishThing}\AgdaSpace{}%
\AgdaPostulate{human}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\>[6]\AgdaFunction{helper}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{mkIrish}\AgdaSpace{}%
\AgdaBound{a}\AgdaSpace{}%
\AgdaBound{isIrish₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaField{Walks.walks}\AgdaSpace{}%
\AgdaPostulate{animalsWalk}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\AgdaSpace{}%
\AgdaBound{a}\<%
\end{code}
\begin{code}[hide]%
%
\>[2]\AgdaFunction{irishDelegateWalks}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{Walks}\AgdaSpace{}%
\AgdaFunction{IrishDelegate}\<%
\\
%
\>[2]\AgdaFunction{irishDelegateWalks}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaKeyword{record}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaSpace{}%
\AgdaField{walks}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{helper}\AgdaSpace{}%
\AgdaSymbol{\}}\<%
\\
\>[2][@{}l@{\AgdaIndent{0}}]%
\>[4]\AgdaKeyword{where}\<%
\\
\>[4][@{}l@{\AgdaIndent{0}}]%
\>[6]\AgdaFunction{helper}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{irishThing}\AgdaSpace{}%
\AgdaPostulate{delegate}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
%
\>[6]\AgdaFunction{helper}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{mkIrish}\AgdaSpace{}%
\AgdaBound{d}\AgdaSpace{}%
\AgdaBound{isIrish₁}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaField{Walks.walks}\AgdaSpace{}%
\AgdaPostulate{animalsWalk}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{\$}}\AgdaSpace{}%
\AgdaBound{d}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{thm?}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{some}\AgdaSpace{}%
\AgdaFunction{IrishDelegate}\AgdaSpace{}%
\AgdaField{walks}%
\>[33]\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{some}\AgdaSpace{}%
\AgdaFunction{IrishHuman}\AgdaSpace{}%
\AgdaField{walks}\<%
\\
\>[0]\AgdaFunction{thm?}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{mkIrish}\AgdaSpace{}%
\AgdaBound{del}\AgdaSpace{}%
\AgdaBound{isIrish[del]}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{snd}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{mkIrish}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPostulate{dh}\AgdaSpace{}%
\AgdaBound{del}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{isIrish[del]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{snd}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{id}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaSymbol{\{}\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSymbol{\}}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaBound{A}\<%
\\
\>[0]\AgdaFunction{id}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaBound{x}\<%
\end{code}

We can now prove analagous theorems to what we showed earlier, with the
adjectival modification showing as extra data in both the input and output. One
can always forsake the Irish detail and prove a weaker conclusion, as in
\term{thm5}.

\begin{code}%
\>[0]\AgdaFunction{thm4}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{some}\AgdaSpace{}%
\AgdaFunction{IrishHuman}\AgdaSpace{}%
\AgdaField{walks}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{some}\AgdaSpace{}%
\AgdaFunction{IrishAnimal}\AgdaSpace{}%
\AgdaField{walks}\<%
\\
\>[0]\AgdaFunction{thm4}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{mkIrish}\AgdaSpace{}%
\AgdaBound{hum}\AgdaSpace{}%
\AgdaBound{isIrish[hum]}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{snd}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{mkIrish}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPostulate{ha}\AgdaSpace{}%
\AgdaBound{hum}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaBound{isIrish[hum]}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{snd}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{thm5}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{some}\AgdaSpace{}%
\AgdaFunction{IrishHuman}\AgdaSpace{}%
\AgdaField{walks}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{some}\AgdaSpace{}%
\AgdaPostulate{animal}\AgdaSpace{}%
\AgdaField{walks}\<%
\\
\>[0]\AgdaFunction{thm5}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{mkIrish}\AgdaSpace{}%
\AgdaBound{hum}\AgdaSpace{}%
\AgdaBound{isIrish[hum]}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{snd}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPostulate{ha}\AgdaSpace{}%
\AgdaBound{hum}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{snd}\<%
\end{code}

If we now decide to now assume some anonymous \term{irishHuman} exists, and we
prove that human is an animal in \term{irishAnimal}, we can see the fruits of
our labor insofar as the identity funtion works in \term{thm6} despite the
property of our specimin walking being of different types. In \term{thm7}, we
can also then use our anonymous human as a witness for the existential claim
that ``some Irish animal walks".

\begin{code}%
\>[0]\AgdaKeyword{postulate}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaPostulate{irishHuman}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{irishThing}\AgdaSpace{}%
\AgdaPostulate{human}\AgdaSpace{}%
\AgdaSymbol{\{\{}\AgdaFunction{hoc}\AgdaSymbol{\}\}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{instance}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaFunction{irishAnimal}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{irishThing}\AgdaSpace{}%
\AgdaPostulate{animal}\<%
\\
%
\>[2]\AgdaFunction{irishAnimal}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{mkIrish}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPostulate{ha}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{irishThing.thing}\AgdaSpace{}%
\AgdaPostulate{irishHuman}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{irishThing.isIrish}\AgdaSpace{}%
\AgdaPostulate{irishHuman}\AgdaSymbol{)}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{thm6}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{walks}\AgdaSpace{}%
\AgdaFunction{irishAnimal}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaField{walks}\AgdaSpace{}%
\AgdaPostulate{irishHuman}\<%
\\
\>[0]\AgdaFunction{thm6}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaFunction{id}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{thm7}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaField{walks}\AgdaSpace{}%
\AgdaPostulate{irishHuman}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{some}\AgdaSpace{}%
\AgdaFunction{IrishAnimal}\AgdaSpace{}%
\AgdaField{walks}\<%
\\
\>[0]\AgdaFunction{thm7}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{=}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{mkIrish}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaPostulate{ha}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaField{irishThing.thing}\AgdaSpace{}%
\AgdaPostulate{irishHuman}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaSymbol{((}\AgdaField{irishThing.isIrish}\AgdaSpace{}%
\AgdaPostulate{irishHuman}\AgdaSymbol{))}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{,}}\AgdaSpace{}%
\AgdaBound{x}\<%
\end{code}

One might try to prove something even sillier, like that an Irish animal is an
Irish thing object. Problematically, for the instance checker to be happy, we need to reflexivly coerce an object due to the constraint that a coercion to an object must exist to build and \term{irishThing}. This then makes it so that if we want to 

\begin{code}%
\>[0]\AgdaKeyword{postulate}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaPostulate{oo}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPostulate{object}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPostulate{object}\<%
\\
\>[0]\AgdaKeyword{instance}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaFunction{ooc}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌞}}\AgdaSpace{}%
\AgdaPostulate{oo}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌟}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{postulate}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaPostulate{irishHumanisIrishThing}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaRecord{irishThing}\AgdaSpace{}%
\AgdaPostulate{animal}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaRecord{irishThing}\AgdaSpace{}%
\AgdaPostulate{object}\<%
\end{code}

If one tries to prove this though, it's impossible to complete the program.

\begin{verbatim}
irishHumanisIrishThing (mkIrish thing isIrish) = mkIrish ((ao (thing))) {!!}
\end{verbatim}

Agda computes with the reflexive coercion instance, and therefore we come to the unredeemable goal :

\begin{verbatim}
Goal: irish $ ao thing
Have: irish $ thing
\end{verbatim}

One might think to just add an extra instance to appease Agda :

\begin{code}%
\>[0]\AgdaKeyword{instance}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaFunction{aooc}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌞}}\AgdaSpace{}%
\AgdaPostulate{ao}\AgdaSpace{}%
\AgdaOperator{\AgdaInductiveConstructor{⌟}}\AgdaSpace{}%
\AgdaOperator{\AgdaFunction{⊚}}\AgdaSpace{}%
\AgdaFunction{ooc}\<%
\end{code}

However, if we were to add an additional instance allowing an animal to be
coerced to an object, this would break the necessary uniqueness of instance
arguements, consistent with the uniqueness of coercions property in type
theories supporting coercive subtyping. This example highlights the limitations
of working with a make-believe subtyping mechanism. While instances give the
Agda programmer the benefits of ad-hoc polymorphism, they are is still not a substitute for a type theory with coercive subtyping built in, especially when it comes to MTT semantics.

\subsection{Addendum on Inductive Types}

\begin{code}%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Men}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{CN}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{Steve}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Men}\<%
\\
%
\>[2]\AgdaInductiveConstructor{Dave}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Men}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{Human}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{CN}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
\>[0][@{}l@{\AgdaIndent{0}}]%
\>[2]\AgdaInductiveConstructor{MenHuman}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Men}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaDatatype{Human}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{SteveHuman}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Human}\<%
\\
\>[0]\AgdaFunction{SteveHuman}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{MenHuman}\AgdaSpace{}%
\AgdaInductiveConstructor{Steve}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaComment{-- what if we map this to actual evidence}\<%
\\
\>[0]\AgdaFunction{Walk}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Human}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaFunction{Walk}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{MenHuman}\AgdaSpace{}%
\AgdaInductiveConstructor{Steve}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaRecord{⊤}\<%
\\
\>[0]\AgdaFunction{Walk}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{MenHuman}\AgdaSpace{}%
\AgdaInductiveConstructor{Dave}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaRecord{⊤}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{allmenWalk}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{all}\AgdaSpace{}%
\AgdaDatatype{Men}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Walk}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{MenHuman}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaFunction{allmenWalk}\AgdaSpace{}%
\AgdaInductiveConstructor{Steve}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\<%
\\
\>[0]\AgdaFunction{allmenWalk}\AgdaSpace{}%
\AgdaInductiveConstructor{Dave}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaKeyword{data}\AgdaSpace{}%
\AgdaDatatype{⊥}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaPrimitive{Set}\AgdaSpace{}%
\AgdaKeyword{where}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{Walk'}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaDatatype{Human}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaPrimitive{Set}\<%
\\
\>[0]\AgdaFunction{Walk'}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{MenHuman}\AgdaSpace{}%
\AgdaInductiveConstructor{Steve}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaRecord{⊤}\<%
\\
\>[0]\AgdaFunction{Walk'}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{MenHuman}\AgdaSpace{}%
\AgdaInductiveConstructor{Dave}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaDatatype{⊥}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{someManWalks'}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{some}\AgdaSpace{}%
\AgdaDatatype{Men}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Walk'}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{MenHuman}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaField{proj₁}\AgdaSpace{}%
\AgdaFunction{someManWalks'}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{Steve}\<%
\\
\>[0]\AgdaField{proj₂}\AgdaSpace{}%
\AgdaFunction{someManWalks'}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaComment{-- allmenDontWalk : all Men λ x → Walk' (MenHuman x)}\<%
\\
\>[0]\AgdaComment{-- allmenDontWalk Steve = tt}\<%
\\
\>[0]\AgdaComment{-- allmenDontWalk Dave = \{!!\}}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{steveWalks}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{Walk}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{MenHuman}\AgdaSpace{}%
\AgdaInductiveConstructor{Steve}\AgdaSymbol{)}\AgdaSpace{}%
\AgdaComment{-- : all Men λ x → Walk (MenHuman x)}\<%
\\
\>[0]\AgdaFunction{steveWalks}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\<%
\\
%
\\[\AgdaEmptyExtraSkip]%
\>[0]\AgdaFunction{someManWalks}\AgdaSpace{}%
\AgdaSymbol{:}\AgdaSpace{}%
\AgdaFunction{some}\AgdaSpace{}%
\AgdaDatatype{Men}\AgdaSpace{}%
\AgdaSymbol{λ}\AgdaSpace{}%
\AgdaBound{x}\AgdaSpace{}%
\AgdaSymbol{→}\AgdaSpace{}%
\AgdaFunction{Walk}\AgdaSpace{}%
\AgdaSymbol{(}\AgdaInductiveConstructor{MenHuman}\AgdaSpace{}%
\AgdaBound{x}\AgdaSymbol{)}\<%
\\
\>[0]\AgdaField{proj₁}\AgdaSpace{}%
\AgdaFunction{someManWalks}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{Steve}\<%
\\
\>[0]\AgdaField{proj₂}\AgdaSpace{}%
\AgdaFunction{someManWalks}\AgdaSpace{}%
\AgdaSymbol{=}\AgdaSpace{}%
\AgdaInductiveConstructor{tt}\<%
\end{code}
