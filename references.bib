
@misc{nassli,
  author = {Unknown},
  title = {{Course 5: Montague’s approach to semantics}},
  year = 2014,
  publisher = {NASSLLI},
  howpublished = {\url{https://pdfs.semanticscholar.org/f94b/268c1c91dd1de22cf978a7ea03f8860cbe9d.pdf}}
}


@article{ljunglof2012bilingual,
  title={A bilingual treebank for the FraCaS test suite},
  author={Ljungl{\"o}f, Peter and Siverbo, Magdalena},
  journal={SLTC 2012},
  pages={53},
  year={2012}
}

@inproceedings{fracoq,
    title = "A Type-Theoretical system for the {F}ra{C}a{S} test suite: Grammatical Framework meets Coq",
    author = "Bernardy, Jean-Philippe  and
      Chatzikyriakidis, Stergios",
    booktitle = "{IWCS} 2017 - 12th International Conference on Computational Semantics - Long papers",
    year = "2017",
    url = "https://aclanthology.org/W17-6801",
}

@techreport{cooper1996using,
  title={Using the framework},
  author={Cooper, Robin and Crouch, Dick and Van Eijck, Jan and Fox, Chris and Van Genabith, Johan and Jaspars, Jan and Kamp, Hans and Milward, David and Pinkal, Manfred and Poesio, Massimo and others},
  year={1996}
}

@article{luo13,
  author    = {Zhaohui Luo and
               Sergei Soloviev and
               Tao Xue},
  title     = {Coercive subtyping: Theory and implementation},
  journal   = {Inf. Comput.},
  volume    = {223},
  pages     = {18--42},
  year      = {2013},
  url       = {https://doi.org/10.1016/j.ic.2012.10.020},
  doi       = {10.1016/j.ic.2012.10.020},
  timestamp = {Fri, 12 Feb 2021 22:16:16 +0100},
  biburl    = {https://dblp.org/rec/journals/iandc/LuoSX13.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{luoCoer,
  author    = {Zhaohui Luo},
  title     = {Coercions in a polymorphic type system},
  journal   = {Math. Struct. Comput. Sci.},
  volume    = {18},
  number    = {4},
  pages     = {729--751},
  year      = {2008},
  url       = {https://doi.org/10.1017/S0960129508006804},
  doi       = {10.1017/S0960129508006804},
  timestamp = {Wed, 01 Apr 2020 08:48:58 +0200},
  biburl    = {https://dblp.org/rec/journals/mscs/Luo08.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{luoCoq,
  author    = {Stergios Chatzikyriakidis and
               Zhaohui Luo},
  title     = {Natural Language Inference in Coq},
  journal   = {J. Log. Lang. Inf.},
  volume    = {23},
  number    = {4},
  pages     = {441--480},
  year      = {2014},
  url       = {https://doi.org/10.1007/s10849-014-9208-x},
  doi       = {10.1007/s10849-014-9208-x},
  timestamp = {Thu, 17 Sep 2020 12:00:16 +0200},
  biburl    = {https://dblp.org/rec/journals/jolli/ChatzikyriakidisL14.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{luoSterg,
  author    = {Stergios Chatzikyriakidis and
               Zhaohui Luo},
  editor    = {Denys Duchier and
               Yannick Parmentier},
  title     = {An Account of Natural Language Coordination in Type Theory with Coercive
               Subtyping},
  booktitle = {Constraint Solving and Language Processing - 7th International Workshop,
               {CSLP} 2012, Orl{\'{e}}ans, France, September 13-14, 2012, Revised
               Selected Papers},
  series    = {Lecture Notes in Computer Science},
  volume    = {8114},
  pages     = {31--51},
  publisher = {Springer},
  year      = {2012},
  url       = {https://doi.org/10.1007/978-3-642-41578-4\_3},
  doi       = {10.1007/978-3-642-41578-4\_3},
  timestamp = {Tue, 14 May 2019 10:00:42 +0200},
  biburl    = {https://dblp.org/rec/conf/cslp/ChatzikyriakidisL12.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{cnTypes,
  author    = {Zhaohui Luo},
  editor    = {Denis B{\'{e}}chet and
               Alexander Ja. Dikovsky},
  title     = {Common Nouns as Types},
  booktitle = {Logical Aspects of Computational Linguistics - 7th International Conference,
               {LACL} 2012, Nantes, France, July 2-4, 2012. Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {7351},
  pages     = {173--185},
  publisher = {Springer},
  year      = {2012},
  url       = {https://doi.org/10.1007/978-3-642-31262-5\_12},
  doi       = {10.1007/978-3-642-31262-5\_12},
  timestamp = {Tue, 14 May 2019 10:00:51 +0200},
  biburl    = {https://dblp.org/rec/conf/lacl/Luo12.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@book{luobook,
  author    = {Zhaohui Luo},
  title     = {Computation and reasoning - a type theory for computer science},
  series    = {International series of monographs on computer science},
  volume    = {11},
  publisher = {Oxford University Press},
  year      = {1994},
  isbn      = {978-0-19-853835-6},
  timestamp = {Fri, 19 Jul 2019 16:04:28 +0200},
  biburl    = {https://dblp.org/rec/books/daglib/0078470.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}
@inproceedings{luoMt,
author = {Luo, Zhaohui},
year = {2014},
month = {06},
pages = {},
title = {Formal Semantics in Modern Type Theories: Is It Model-Theoretic, Proof-Theoretic, or Both?},
doi = {10.1007/978-3-662-43742-1_14}
}

@book{ranta1994type,
  title={{Type Theoretical Grammar}},
  author={Ranta, A.},
  year={1994},
  publisher={Oxford University Press}
}

@Inbook{Sundholm1986,
author="Sundholm, G{\"o}ran",
editor="Gabbay, D.
and Guenthner, F.",
title="Proof Theory and Meaning",
bookTitle="Handbook of Philosophical Logic: Volume III: Alternatives in Classical Logic",
year="1986",
publisher="Springer Netherlands",
address="Dordrecht",
pages="471--506",
abstract="The meaning of a sentence determines how the truth of the proposition expressed by the sentence may be proved and hence one would expect proof theory to be influenced by meaning-theoretical considerations. In the present Chapter we consider a proposal that also reverses the above priorities and determines meaning in terms of proof. The proposal originates in the criticism that Michael Dummett has voiced against a realist, truth-theoretical, conception of meaning and has been developed largely by him and Dag Prawitz, whose normalization procedures in technical proof theory constitute the main technical basis of the proposal.",
isbn="978-94-009-5203-4",
doi="10.1007/978-94-009-5203-4_8",
url="https://doi.org/10.1007/978-94-009-5203-4_8"
}

@book{ml1984,
	Author = {Martin-L{\"o}f, Per},
	Isbn = {88-7088-105-9},
	Mrclass = {03B15 (03F50 03F55)},
	Mrnumber = {769301 (86j:03005)},
	Mrreviewer = {M. M. Richter},
	Pages = {iv+91},
	Publisher = {Bibliopolis},
	Series = {Studies in Proof Theory},
	Note = {Notes by Giovanni Sambin of a series of lectures given in Padua, June 1980},
	Title = {Intuitionistic type theory},
	Volume = {1},
	Year = {1984}}


@book{prawitz2006natural,
  title={Natural deduction: A proof-theoretical study},
  author={Prawitz, Dag},
  year={2006},
  publisher={Courier Dover Publications}
}

@article{Gentzen1935,
author = {Gentzen, G.},
journal = {Mathematische Zeitschrift},
keywords = {foundations, philosophy, logic},
pages = {176-210},
title = {Untersuchungen über das logische Schließen I},
url = {http://eudml.org/doc/168546},
volume = {39},
year = {1935},
}

@Inbook{Montague1973,
author="Montague, Richard",
editor="Hintikka, K. J. J.
and Moravcsik, J. M. E.
and Suppes, P.",
title="The Proper Treatment of Quantification in Ordinary English",
bookTitle="Approaches to Natural Language: Proceedings of the 1970 Stanford Workshop on Grammar and Semantics",
year="1973",
publisher="Springer Netherlands",
address="Dordrecht",
pages="221--242",
abstract="The aim of this paper is to present in a rigorous way the syntax and semantics of a certain fragment of a certain dialect of English. For expository purposes the fragment has been made as simple and restricted as it can be while accommodating all the more puzzling cases of quantification and reference with which I am acquainted.1",
isbn="978-94-010-2506-5",
doi="10.1007/978-94-010-2506-5_10",
url="https://doi.org/10.1007/978-94-010-2506-5_10"
}


@misc{niu2020costaware,
      title={Cost-Aware Type Theory}, 
      author={Yue Niu and Robert Harper},
      year={2021},
      eprint={2011.03660},
      archivePrefix={arXiv},
      primaryClass={cs.PL}
}

@misc{schreiber2014quantization,
      title={Quantization via Linear homotopy types}, 
      author={Urs Schreiber},
      year={2014},
      eprint={1402.7041},
      archivePrefix={arXiv},
      primaryClass={math-ph}
}

@misc{shulman2018linear,
      title={Linear logic for constructive mathematics}, 
      author={Michael Shulman},
      year={2018},
      eprint={1805.07518},
      archivePrefix={arXiv},
      primaryClass={math.LO}
}

@InProceedings{cavallo2021internal,
  author =	{Evan Cavallo and Robert Harper},
  title =	{{Internal Parametricity for Cubical Type Theory}},
  booktitle =	{28th EACSL Annual Conference on Computer Science Logic (CSL 2020)},
  pages =	{13:1--13:17},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-132-0},
  ISSN =	{1868-8969},
  year =	{2020},
  volume =	{152},
  editor =	{Maribel Fern{\'a}ndez and Anca Muscholl},
  publisher =	{Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/opus/volltexte/2020/11656},
  URN =		{urn:nbn:de:0030-drops-116564},
  doi =		{10.4230/LIPIcs.CSL.2020.13},
  annote =	{Keywords: parametricity, cubical type theory, higher inductive types}
}

@article{marco2019,
author = {Qu, Weihao and Gaboardi, Marco and Garg, Deepak},
title = {Relational Cost Analysis for Functional-Imperative Programs},
year = {2019},
issue_date = {August 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {ICFP},
url = {https://doi.org/10.1145/3341696},
doi = {10.1145/3341696},
abstract = {Relational cost analysis aims at formally establishing bounds on the difference in the evaluation costs of two programs. As a particular case, one can also use relational cost analysis to establish bounds on the difference in the evaluation cost of the same program on two different inputs. One way to perform relational cost analysis is to use a relational type-and-effect system that supports reasoning about relations between two executions of two programs.  Building on this basic idea, we present a type-and-effect system, called ARel, for reasoning about the relative cost of array-manipulating, higher-order functional-imperative programs. The key ingredient of our approach is a new lightweight type refinement discipline that we use to track relations (differences) between two mutable arrays. This discipline combined with Hoare-style triples built into the types allows us to express and establish precise relative costs of several interesting programs which imperatively update their data. We have implemented ARel using ideas from bidirectional type checking.},
journal = {Proc. ACM Program. Lang.},
month = jul,
articleno = {92},
numpages = {29},
keywords = {refinement types, type-and-effect systems, relational type systems}
}

@article{HOFMANN200357,
title = {Linear types and non-size-increasing polynomial time computation},
journal = {Information and Computation},
volume = {183},
number = {1},
pages = {57-85},
year = {2003},
note = {International Workshop on Implicit Computational Complexity (ICC'99)},
issn = {0890-5401},
doi = {https://doi.org/10.1016/S0890-5401(03)00009-9},
url = {https://www.sciencedirect.com/science/article/pii/S0890540103000099},
author = {Martin Hofmann},
keywords = {Complexity theory, Type system, Linear types, Higher-order function, Resources},
abstract = {We propose a linear type system with recursion operators for inductive datatypes which ensures that all definable functions are polynomial time computable. The system improves upon previous such systems in that recursive definitions can be arbitrarily nested; in particular, no predicativity or modality restrictions are made.}
}

@INPROCEEDINGS{5970211,
  author={U. {Dal Lago} and M. {Gaboardi}},
  booktitle={2011 IEEE 26th Annual Symposium on Logic in Computer Science}, 
  title={Linear Dependent Types and Relative Completeness}, 
  year={2011},
  volume={},
  number={},
  pages={133-142},
  doi={10.1109/LICS.2011.22}}

@article{gaboardiP,
author = {Gaboardi, Marco and Haeberlen, Andreas and Hsu, Justin and Narayan, Arjun and Pierce, Benjamin C.},
title = {Linear Dependent Types for Differential Privacy},
year = {2013},
issue_date = {January 2013},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {48},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/2480359.2429113},
doi = {10.1145/2480359.2429113},
abstract = {Differential privacy offers a way to answer queries about sensitive information while providing strong, provable privacy guarantees, ensuring that the presence or absence of a single individual in the database has a negligible statistical effect on the query's result. Proving that a given query has this property involves establishing a bound on the query's sensitivity---how much its result can change when a single record is added or removed.A variety of tools have been developed for certifying that a given query differentially private. In one approach, Reed and Pierce [34] proposed a functional programming language, Fuzz, for writing differentially private queries. Fuzz uses linear types to track sensitivity and a probability monad to express randomized computation; it guarantees that any program with a certain type is differentially private. Fuzz can successfully verify many useful queries. However, it fails when the sensitivity analysis depends on values that are not known statically.We present DFuzz, an extension of Fuzz with a combination of linear indexed types and lightweight dependent types. This combination allows a richer sensitivity analysis that is able to certify a larger class of queries as differentially private, including ones whose sensitivity depends on runtime information. As in Fuzz, the differential privacy guarantee follows directly from the soundness theorem of the type system. We demonstrate the enhanced expressivity of DFuzz by certifying differential privacy for a broad class of iterative algorithms that could not be typed previously.},
journal = {SIGPLAN Not.},
month = jan,
pages = {357–370},
numpages = {14},
keywords = {type systems, differential privacy, dependent types, linear logic}
}

@article{selingerQuantum,
  author    = {Peng Fu and
               Kohei Kishida and
               Peter Selinger},
  title     = {Linear Dependent Type Theory for Quantum Programming Languages},
  journal   = {CoRR},
  volume    = {abs/2004.13472},
  year      = {2020},
  url       = {https://arxiv.org/abs/2004.13472},
  archivePrefix = {arXiv},
  eprint    = {2004.13472},
  timestamp = {Thu, 23 Jul 2020 16:22:11 +0200},
  biburl    = {https://dblp.org/rec/journals/corr/abs-2004-13472.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@misc{angiuli2020internalizing,
      title={Internalizing Representation Independence with Univalence}, 
      author={Carlo Angiuli and Evan Cavallo and Anders Mörtberg and Max Zeuner},
      year={2020},
      eprint={2009.05547},
      archivePrefix={arXiv},
      primaryClass={cs.PL}
}

@article{marcoRel,
author = {Aguirre, Alejandro and Barthe, Gilles and Gaboardi, Marco and Garg, Deepak and Strub, Pierre-Yves},
title = {A Relational Logic for Higher-Order Programs},
year = {2017},
issue_date = {September 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {1},
number = {ICFP},
url = {https://doi.org/10.1145/3110265},
doi = {10.1145/3110265},
abstract = {Relational program verification is a variant of program verification where one can reason about two programs and as a special case about two executions of a single program on different inputs. Relational program verification can be used for reasoning about a broad range of properties, including equivalence and refinement, and specialized notions such as continuity, information flow security or relative cost. In a higher-order setting, relational program verification can be achieved using relational refinement type systems, a form of refinement types where assertions have a relational interpretation. Relational refinement type systems excel at relating structurally equivalent terms but provide limited support for relating terms with very different structures. We present a logic, called Relational Higher Order Logic (RHOL), for proving relational properties of a simply typed λ-calculus with inductive types and recursive definitions. RHOL retains the type-directed flavour of relational refinement type systems but achieves greater expressivity through rules which simultaneously reason about the two terms as well as rules which only contemplate one of the two terms. We show that RHOL has strong foundations, by proving an equivalence with higher-order logic (HOL), and leverage this equivalence to derive key meta-theoretical properties: subject reduction, admissibility of a transitivity rule and set-theoretical soundness. Moreover, we define sound embeddings for several existing relational type systems such as relational refinement types and type systems for dependency analysis and relative cost, and we verify examples that were out of reach of prior work.},
journal = {Proc. ACM Program. Lang.},
month = aug,
articleno = {21},
numpages = {29},
keywords = {Formal Verification, Refinement Types, Relational Logic}
}

@article{neelBenton,
author = {Krishnaswami, Neelakantan R. and Pradic, Pierre and Benton, Nick},
title = {Integrating Linear and Dependent Types},
year = {2015},
issue_date = {January 2015},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {50},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/2775051.2676969},
doi = {10.1145/2775051.2676969},
abstract = {In this paper, we show how to integrate linear types with type dependency, by extending the linear/non-linear calculus of Benton to support type dependency. Next, we give an application of this calculus by giving a proof-theoretic account of imperative programming, which requires extending the calculus with computationally irrelevant quantification, proof irrelevance, and a monad of computations. We show the soundness of our theory by giving a realizability model in the style of Nuprl, which permits us to validate not only the beta-laws for each type, but also the eta-laws. These extensions permit us to decompose Hoare triples into a collection of simpler type-theoretic connectives, yielding a rich equational theory for dependently-typed higher-order imperative programs. Furthermore, both the type theory and its model are relatively simple, even when all of the extensions are considered.},
journal = {SIGPLAN Not.},
month = jan,
pages = {17–30},
numpages = {14},
keywords = {dependent types, hoare triples, separation logic, proof irrelevance, intersection types, linear types}
}

@inproceedings{bentonCat,
author = {Benton, P. N. and Bierman, Gavin M. and Paiva, Valeria de and Hyland, Martin},
title = {A Term Calculus for Intuitionistic Linear Logic},
year = {1993},
isbn = {3540565175},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
booktitle = {Proceedings of the International Conference on Typed Lambda Calculi and Applications},
pages = {75–90},
numpages = {16},
series = {TLCA '93}
}

@misc{vákár2015syntax,
      title={Syntax and Semantics of Linear Dependent Types}, 
      author={Matthijs Vákár},
      year={2015},
      eprint={1405.0033},
      archivePrefix={arXiv},
      primaryClass={cs.LO}
}

@misc{luoLinear,
      title= {A linear dependent type theory}, 
      author={Z. Luo and Y. Zhang},
      year={2016},
			url = {http://www.cs.rhul.ac.uk/~zhaohui/TYPES16.pdf},
			journal   = {TYPES 2016},
}


@unpublished{mellies:hal-00154229,
  TITLE = {{Categorical models of linear logic revisited}},
  AUTHOR = {Melli{\`e}s, Paul-Andr{\'e}},
  URL = {https://hal.archives-ouvertes.fr/hal-00154229},
  NOTE = {working paper or preprint},
  HAL_LOCAL_REFERENCE = {pps//03/09//n{\textdegree}22 (pp)},
  YEAR = {2003},
  MONTH = Oct,
  KEYWORDS = {Linear logic ; categories ; coherence space},
  PDF = {https://hal.archives-ouvertes.fr/hal-00154229/file/catmodels.pdf},
  HAL_ID = {hal-00154229},
  HAL_VERSION = {v1},
}

@article{Caires2016LinearLP,
  title={Linear logic propositions as session types},
  author={L. Caires and F. Pfenning and Bernardo Toninho},
  journal={Math. Struct. Comput. Sci.},
  year={2016},
  volume={26},
  pages={367-423}
}

@misc{voevodsky2014equivalence,
      title={The equivalence axiom and univalent models of type theory. (Talk at CMU on February 4, 2010)}, 
      author={Vladimir Voevodsky},
      year={2014},
      eprint={1402.5556},
      archivePrefix={arXiv},
      primaryClass={math.LO}
}

@misc{shulman2018linear,
      title={Linear logic for constructive mathematics}, 
      author={Michael Shulman},
      year={2018},
      eprint={1805.07518},
      archivePrefix={arXiv},
      primaryClass={math.LO}
}

@misc{bezem2017univalence,
      title={The univalence axiom in cubical sets}, 
      author={Marc Bezem and Thierry Coquand and Simon Huber},
      year={2017},
      eprint={1710.10941},
      archivePrefix={arXiv},
      primaryClass={math.LO}
}

@inproceedings{cohen:hal-01378906,
  TITLE = {{Cubical Type Theory: a constructive interpretation of the univalence axiom}},
  AUTHOR = {Cohen, Cyril and Coquand, Thierry and Huber, Simon and M{\"o}rtberg, Anders},
  URL = {https://hal.inria.fr/hal-01378906},
  BOOKTITLE = {{21st International Conference on Types for Proofs and Programs}},
  ADDRESS = {Tallinn, Estonia},
  PUBLISHER = {{Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik}},
  SERIES = {21st International Conference on Types for Proofs and Programs},
  NUMBER = {69},
  PAGES = {262},
  YEAR = {2015},
  MONTH = May,
  DOI = {10.4230/LIPIcs.TYPES.2015.5},
  KEYWORDS = {Univalence Axiom ;  Dependent Type Theory ;  Cubical Sets},
  PDF = {https://hal.inria.fr/hal-01378906v2/file/LIPIcs-TYPES-2015-5.pdf},
  HAL_ID = {hal-01378906},
  HAL_VERSION = {v2},
}


@Book{hottbook,
  author =    {The {Univalent Foundations Program}},
  title =     {Homotopy Type Theory: Univalent Foundations of Mathematics},
  publisher = {\url{https://homotopytypetheory.org/book}},
  address =   {Institute for Advanced Study},
  year =      2013}

@article{cubicalAgda,
author = {Vezzosi, Andrea and M\"{o}rtberg, Anders and Abel, Andreas},
title = {Cubical Agda: A Dependently Typed Programming Language with Univalence and Higher Inductive Types},
year = {2019},
issue_date = {August 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {ICFP},
url = {https://doi.org/10.1145/3341691},
doi = {10.1145/3341691},
abstract = {Proof assistants based on dependent type theory provide expressive languages for both programming and proving within the same system. However, all of the major implementations lack powerful extensionality principles for reasoning about equality, such as function and propositional extensionality. These principles are typically added axiomatically which disrupts the constructive properties of these systems. Cubical type theory provides a solution by giving computational meaning to Homotopy Type Theory and Univalent Foundations, in particular to the univalence axiom and higher inductive types. This paper describes an extension of the dependently typed functional programming language Agda with cubical primitives, making it into a full-blown proof assistant with native support for univalence and a general schema of higher inductive types. These new primitives make function and propositional extensionality as well as quotient types directly definable with computational content. Additionally, thanks also to copatterns, bisimilarity is equivalent to equality for coinductive types. This extends Agda with support for a wide range of extensionality principles, without sacrificing type checking and constructivity.},
journal = {Proc. ACM Program. Lang.},
month = jul,
articleno = {87},
numpages = {29},
keywords = {Higher Inductive Types, Cubical Type Theory, Univalence, Dependent Pattern Matching}
}

@InCollection{sep-logic-linear,
	author       =	{Di Cosmo, Roberto and Miller, Dale},
	title        =	{{Linear Logic}},
	booktitle    =	{The {Stanford} Encyclopedia of Philosophy},
	editor       =	{Edward N. Zalta},
	howpublished =	{\url{https://plato.stanford.edu/archives/sum2019/entries/logic-linear/}},
	year         =	{2019},
	edition      =	{Summer 2019},
	publisher    =	{Metaphysics Research Lab, Stanford University}
}

@Book{indexedInf,
  author =    {Probably Urs},
  publisher = {\url{Google indexed monoidal infinity one category}}
}


@Book{neelComment,
  author =    {Krishnaswami, Neelakantan R.},
  publisher = {\url{https://golem.ph.utexas.edu/category/2018/05/linear_logic_for_constructive.html}}
}

@Book{ITC,
  author =    {Initial Types Club},
	publisher = {\url{https://github.com/InitialTypes/Club/wiki}}
}

@misc{harperBeauty,
      title={Two Notions of Beauty in Programming}, 
      author={Robert Harper},
      year={2016},
			journal = {Programming Languages Mentoring Workshop},
			howpublished =	{\url{http://www.cs.cmu.edu/~rwh/talks/plmw16.pdf}}
}

@misc{brunerie2016homotopy,
      title={On the homotopy groups of spheres in homotopy type theory}, 
      author={Guillaume Brunerie},
      year={2016},
      eprint={1606.05916},
      archivePrefix={arXiv},
      primaryClass={math.AT}
}

@misc{andersCohomology,
	title={Synthetic Cohomology Theory in Cubical Agda},
	author={Anders Mörtberg },
	year={2021}
}

@article{raml,
author = {Hoffmann, Jan and Das, Ankush and Weng, Shu-Chun},
title = {Towards Automatic Resource Bound Analysis for OCaml},
year = {2017},
issue_date = {January 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/3093333.3009842},
doi = {10.1145/3093333.3009842},
abstract = { This article presents a resource analysis system for OCaml programs. The system automatically derives worst-case resource bounds for higher-order polymorphic programs with user-defined inductive types. The technique is parametric in the resource and can derive bounds for time, memory allocations and energy usage. The derived bounds are multivariate resource polynomials which are functions of different size parameters that depend on the standard OCaml types. Bound inference is fully automatic and reduced to a linear optimization problem that is passed to an off-the-shelf LP solver. Technically, the analysis system is based on a novel multivariate automatic amortized resource analysis (AARA). It builds on existing work on linear AARA for higher-order programs with user-defined inductive types and on multivariate AARA for first-order programs with built-in lists and binary trees. This is the first amortized analysis, that automatically derives polynomial bounds for higher-order functions and polynomial bounds that depend on user-defined inductive types. Moreover, the analysis handles a limited form of side effects and even outperforms the linear bound inference of previous systems. At the same time, it preserves the expressivity and efficiency of existing AARA techniques. The practicality of the analysis system is demonstrated with an implementation and integration with Inria's OCaml compiler. The implementation is used to automatically derive resource bounds for 411 functions and 6018 lines of code derived from OCaml libraries, the CompCert compiler, and implementations of textbook algorithms. In a case study, the system infers bounds on the number of queries that are sent by OCaml programs to DynamoDB, a commercial NoSQL cloud database service. },
journal = {SIGPLAN Not.},
month = jan,
pages = {359–373},
numpages = {15},
keywords = {Resource Bound Analysis, LP Solving, Type Inference, Amortized Analysis, Type Systems, Static Analysis}
}

@INPROCEEDINGS{705656,
  author={C. {Hermida} and M. {Makkai} and J. {Power}},
  booktitle={Proceedings. Thirteenth Annual IEEE Symposium on Logic in Computer Science (Cat. No.98CB36226)}, 
  title={Higher dimensional multigraphs}, 
  year={1998},
  volume={},
  number={},
  pages={199-206},
  doi={10.1109/LICS.1998.705656}}

@inproceedings{agda,
author = {Norell, Ulf},
title = {Dependently Typed Programming in Agda},
year = {2008},
isbn = {3642046517},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
booktitle = {Proceedings of the 6th International Conference on Advanced Functional Programming},
pages = {230–266},
numpages = {37},
location = {Heijen, The Netherlands},
series = {AFP'08}
}

  
@book{Pierce:SF2,
  author = {Benjamin C. Pierce and Arthur Azevedo de Amorim 
                  and Chris Casinghino and Marco Gaboardi and
                  Michael Greenberg and C\v{a}t\v{a}lin Hri\c{t}cu 
                  and Vilhelm Sj\"{o}berg and Andrew Tolmach
                  and Brent Yorgey},
  title = {Programming Language Foundations},
  series = {Software Foundations series, volume 2},
  month = may,
  year = {2018},
  publisher = {Electronic textbook},
  plclub = {Yes},
  bcp = {Yes},
  keys = {verification,books},
  japanese = {http://proofcafe.org/sf}
}

@inproceedings{twelf,
author = {Pfenning, Frank and Sch\"{u}rmann, Carsten},
title = {System Description: Twelf - A Meta-Logical Framework for Deductive Systems},
year = {1999},
isbn = {3540662227},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
abstract = {Twelf is a meta-logical framework for the specification, implementation, and meta-theory of deductive systems from the theory of programming languages and logics. It relies on the LF type theory and the judgments-as-types methodology for specification [HHP93], a constraint logic programming interpreter for implementation [Pfe91], and the meta-logic M2 for reasoning about object languages encoded in LF [SP98]. It is a significant extension and complete reimplementation of the Elf system [Pfe94].Twelf is written in Standard ML and runs under SML of New Jersey and MLWorks on Unix and Window platforms. The current version (1.2) is distributed with a complete manual, example suites, a tutorial in the form of on-line lecture notes [Pfe], and an Emacs interface. Source and binary distributions are accessible via the Twelf home page http://www.cs.cmu.edu/~twelf.},
booktitle = {Proceedings of the 16th International Conference on Automated Deduction: Automated Deduction},
pages = {202–206},
numpages = {5},
series = {CADE-16}
}

@article{lfHarper,
author = {Harper, Robert and Honsell, Furio and Plotkin, Gordon},
title = {A Framework for Defining Logics},
year = {1993},
issue_date = {Jan. 1993},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {40},
number = {1},
issn = {0004-5411},
url = {https://doi.org/10.1145/138027.138060},
doi = {10.1145/138027.138060},
abstract = {The Edinburgh Logical Framework (LF) provides a means to define (or present) logics. It is based on a general treatment of syntax, rules, and proofs by means of a typed λ-calculus with dependent types. Syntax is treated in a style similar to, but more general than, Martin-Lo¨f's system of arities. The treatment of rules and proofs focuses on his notion of a judgment. Logics are represented in LF via a new principle, the judgments as types principle, whereby each judgment is identified with the type of its proofs. This allows for a smooth treatment of discharge and variable occurence conditions and leads to a uniform treatment of rules and proofs whereby rules are viewed as proofs of higher-order judgments and proof checking is reduced to type checking. The practical benefit of our treatment of formal systems is that logic-independent tools, such as proof editors and proof checkers, can be constructed.},
journal = {J. ACM},
month = jan,
pages = {143–184},
numpages = {42},
keywords = {proof checking, typed lambda calculus, interactive theorem proving, formal systems}
}

@misc{formalAbstracts,
	title={AN ARGUMENT FOR CONTROLLED NATURAL LANGUAGES IN MATHEMATICS},
	author={Thomas Hales},
	year={2019}
}
  
@article{gf,
author = {Ranta, Aarne},
title = {Grammatical Framework},
year = {2004},
issue_date = {March 2004},
publisher = {Cambridge University Press},
address = {USA},
volume = {14},
number = {2},
issn = {0956-7968},
url = {https://doi.org/10.1017/S0956796803004738},
doi = {10.1017/S0956796803004738},
abstract = {Grammatical Framework (GF) is a special-purpose functional language for defining grammars. It uses a Logical Framework (LF) for a description of abstract syntax, and adds to this a notation for defining concrete syntax. GF grammars themselves are purely declarative, but can be used both for linearizing syntax trees and parsing strings. GF can describe both formal and natural languages. The key notion of this description is a grammatical object, which is not just a string, but a record that contains all information on inflection and inherent grammatical features such as number and gender in natural languages, or precedence in formal languages. Grammatical objects have a type system, which helps to eliminate run-time errors in language processing. In the same way as a LF, GF uses dependent types in abstract syntax to express semantic conditions, such as well-typedness and proof obligations. Multilingual grammars, where one abstract syntax has many parallel concrete syntaxes, can be used for reliable and meaning-preserving translation. They can also be used in authoring systems, where syntax trees are constructed in an interactive editor similar to proof editors based on LF. While being edited, the trees can simultaneously be viewed in different languages. This paper starts with a gradual introduction to GF, going through a sequence of simpler formalisms till the full power is reached. The introduction is followed by a systematic presentation of the GF formalism and outlines of the main algorithms: partial evaluation and parser generation. The paper concludes by brief discussions of the Haskell implementation of GF, existing applications, and related work.},
journal = {J. Funct. Program.},
month = mar,
pages = {145–189},
numpages = {45}
}

@incollection{ml79,
title = {Constructive Mathematics and Computer Programming},
editor = {L. Jonathan Cohen and Jerzy Łoś and Helmut Pfeiffer and Klaus-Peter Podewski},
series = {Studies in Logic and the Foundations of Mathematics},
publisher = {Elsevier},
volume = {104},
pages = {153-175},
year = {1982},
booktitle = {Logic, Methodology and Philosophy of Science VI},
issn = {0049-237X},
doi = {https://doi.org/10.1016/S0049-237X(09)70189-2},
url = {https://www.sciencedirect.com/science/article/pii/S0049237X09701892},
author = {Per Martin-Löf},
abstract = {Publisher Summary
This chapter discusses that relating constructive mathematics to computer programming seems to be beneficial. Among the benefits to be derived by constructive mathematics from its association with computer programming, one is that you see immediately why you cannot rely upon the law of excluded middle: its uninhibited use would lead to programs that one did not know how to execute. By choosing to program in a formal language for constructive mathematics, like the theory of types, one gets access to the conceptual apparatus of pure mathematics, neglecting those parts that depend critically on the law of excluded middle, whereas even the best high level programming languages so far designed are wholly inadequate as mathematical languages. The virtue of a machine code is that a program written in it can be directly read and executed by the machine. The distinction between low and high level programming languages is of course relative to the available hardware. It may well be possible to turn what is now regarded as a high level programming language into machine code by the invention of new hardware.}
}

@inproceedings{de2015lean,
  title={The Lean theorem prover (system description)},
  author={de Moura, Leonardo and Kong, Soonho and Avigad, Jeremy and Van Doorn, Floris and von Raumer, Jakob},
  booktitle={International Conference on Automated Deduction},
  pages={378--388},
  year={2015},
  organization={Springer}
}

@Book{neelComment,
  author =    {Krishnaswami, Neelakantan R.},
  publisher = {\url{https://golem.ph.utexas.edu/category/2018/05/linear_logic_for_constructive.html}}
}

@Book{honoraria14,
	author = {Burning Man Organization},
	title = {2014 Art Installations},
	publisher = {\url{https://burningman.org/culture/history/brc-history/event-archives/2014-event-archive/2014-art-installations/}}
}

@INPROCEEDINGS{Borges99thelibrary,
    author = {Jorge Luis Borges},
    title = {The Library of Babel},
    booktitle = {in Borges J.L. Collected Fictions (Penguin},
    year = {1999}
}
